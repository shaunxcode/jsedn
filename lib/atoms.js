// Generated by CoffeeScript 1.6.1
(function() {
  var BigInt, Char, Discard, Keyword, Prim, StringObj, Symbol, bigInt, char, charMap, kw, memo, sym, type,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  type = require("./type");

  memo = require("./memo");

  Prim = (function() {

    function Prim(val) {
      var x;
      if (type(val) === "array") {
        this.val = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = val.length; _i < _len; _i++) {
            x = val[_i];
            if (!(x instanceof Discard)) {
              _results.push(x);
            }
          }
          return _results;
        })();
      } else {
        this.val = val;
      }
    }

    Prim.prototype.value = function() {
      return this.val;
    };

    Prim.prototype.toString = function() {
      return JSON.stringify(this.val);
    };

    return Prim;

  })();

  BigInt = (function(_super) {

    __extends(BigInt, _super);

    function BigInt() {
      return BigInt.__super__.constructor.apply(this, arguments);
    }

    BigInt.prototype.ednEncode = function() {
      return this.val;
    };

    BigInt.prototype.jsEncode = function() {
      return this.val;
    };

    BigInt.prototype.jsonEncode = function() {
      return {
        BigInt: this.val
      };
    };

    return BigInt;

  })(Prim);

  StringObj = (function(_super) {

    __extends(StringObj, _super);

    function StringObj() {
      return StringObj.__super__.constructor.apply(this, arguments);
    }

    StringObj.prototype.toString = function() {
      return this.val;
    };

    StringObj.prototype.is = function(test) {
      return this.val === test;
    };

    return StringObj;

  })(Prim);

  charMap = {
    newline: "\n",
    "return": "\r",
    space: " ",
    tab: "\t",
    formfeed: "\f"
  };

  Char = (function(_super) {

    __extends(Char, _super);

    Char.prototype.ednEncode = function() {
      return "\\" + this.val;
    };

    Char.prototype.jsEncode = function() {
      return charMap[this.val] || this.val;
    };

    Char.prototype.jsonEncode = function() {
      return {
        Char: this.val
      };
    };

    function Char(val) {
      if (charMap[val] || val.length === 1) {
        this.val = val;
      } else {
        throw "Char may only be newline, return, space, tab, formfeed or a single character - you gave [" + val + "]";
      }
    }

    return Char;

  })(StringObj);

  Discard = (function() {

    function Discard() {}

    return Discard;

  })();

  Symbol = (function(_super) {

    __extends(Symbol, _super);

    Symbol.prototype.validRegex = /[0-9A-Za-z.*+!\-_?$%&=:#/]+/;

    Symbol.prototype.invalidFirstChars = [":", "#", "/"];

    Symbol.prototype.valid = function(word) {
      var _ref, _ref1, _ref2;
      if (((_ref = word.match(this.validRegex)) != null ? _ref[0] : void 0) !== word) {
        throw "provided an invalid symbol " + word;
      }
      if (word.length === 1 && word[0] !== "/") {
        if (_ref1 = word[0], __indexOf.call(this.invalidFirstChars, _ref1) >= 0) {
          throw "Invalid first character in symbol " + word[0];
        }
      }
      if (((_ref2 = word[0]) === "-" || _ref2 === "+" || _ref2 === ".") && (word[1] != null) && word[1].match(/[0-9]/)) {
        throw "If first char is " + word[0] + " the second char can not be numeric. You had " + word[1];
      }
      if (word[0].match(/[0-9]/)) {
        throw "first character may not be numeric. You provided " + word[0];
      }
      return true;
    };

    function Symbol() {
      var args, parts;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      switch (args.length) {
        case 1:
          if (args[0] === "/") {
            this.ns = null;
            this.name = "/";
          } else {
            parts = args[0].split("/");
            if (parts.length === 1) {
              this.ns = null;
              this.name = parts[0];
              if (this.name === ":") {
                throw "can not have a symbol of only :";
              }
            } else if (parts.length === 2) {
              this.ns = parts[0];
              if (this.ns === "") {
                throw "can not have a slash at start of symbol";
              }
              if (this.ns === ":") {
                throw "can not have a namespace of :";
              }
              this.name = parts[1];
              if (this.name.length === 0) {
                throw "symbol may not end with a slash.";
              }
            } else {
              throw "Can not have more than 1 forward slash in a symbol";
            }
          }
          break;
        case 2:
          this.ns = args[0];
          this.name = args[1];
      }
      if (this.name.length === 0) {
        throw "Symbol can not be empty";
      }
      this.val = "" + (this.ns ? "" + this.ns + "/" : "") + this.name;
      this.valid(this.val);
    }

    Symbol.prototype.toString = function() {
      return this.val;
    };

    Symbol.prototype.ednEncode = function() {
      return this.val;
    };

    Symbol.prototype.jsEncode = function() {
      return this.val;
    };

    Symbol.prototype.jsonEncode = function() {
      return {
        Symbol: this.val
      };
    };

    return Symbol;

  })(Prim);

  Keyword = (function(_super) {

    __extends(Keyword, _super);

    Keyword.prototype.invalidFirstChars = ["#", "/"];

    function Keyword() {
      Keyword.__super__.constructor.apply(this, arguments);
      if (this.val[0] !== ":") {
        throw "keyword must start with a :";
      }
      if ((this.val[1] != null) === "/") {
        throw "keyword can not have a slash with out a namespace";
      }
    }

    Keyword.prototype.jsonEncode = function() {
      return {
        Keyword: this.val
      };
    };

    return Keyword;

  })(Symbol);

  char = memo(Char);

  kw = memo(Keyword);

  sym = memo(Symbol);

  bigInt = memo(BigInt);

  module.exports = {
    Prim: Prim,
    Symbol: Symbol,
    Keyword: Keyword,
    StringObj: StringObj,
    Char: Char,
    Discard: Discard,
    BigInt: BigInt,
    char: char,
    kw: kw,
    sym: sym,
    bigInt: bigInt
  };

}).call(this);
